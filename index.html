<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Neon HairTry â€” Barbershop Preview (Option B)</title>
<style>
  :root{
    --bg1:#0f0c29; --bg2:#302b63; --accent:#ff4da6; --accent2:#7afcff; --muted:#eaf2ff;
  }
  html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;}
  body{
    background:linear-gradient(120deg,var(--bg1),var(--bg2));
    color:var(--muted);
    display:flex;flex-direction:column;align-items:center;padding:18px;gap:12px;overflow:auto;
    -webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;
  }
  .neon-bg{position:fixed;inset:0;z-index:0;pointer-events:none;background:
    radial-gradient(600px 300px at 10% 20%, rgba(255,77,166,0.06), transparent 8%),
    radial-gradient(600px 300px at 80% 80%, rgba(122,252,255,0.04), transparent 8%);
    filter:blur(40px); animation:bgmove 18s linear infinite}
  @keyframes bgmove{0%{transform:translateX(-5%)}50%{transform:translateX(5%)}100%{transform:translateX(-5%)}}

  header{z-index:2;width:100%;max-width:1100px;display:flex;align-items:center;gap:12px}
  .logo{width:44px;height:44px;border-radius:10px;background:linear-gradient(45deg,var(--accent),#ff8a66);display:flex;align-items:center;justify-content:center;font-weight:700;color:#111}

  main{z-index:2;display:flex;gap:18px;width:100%;max-width:1100px}
  .left,.right{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:14px;padding:14px;box-shadow:0 12px 40px rgba(0,0,0,0.6);backdrop-filter: blur(6px)}
  .left{flex:1;min-width:320px} .right{width:360px}

  /* single 1x1 inch upload */
  .uploadRow{display:flex;gap:12px;align-items:center}
  .dropTarget{width:1in;height:1in;border-radius:8px;border:1px dashed rgba(255,255,255,0.12);display:flex;align-items:center;justify-content:center;cursor:pointer;background:linear-gradient(180deg,rgba(255,255,255,0.01),rgba(255,255,255,0.00));position:relative}
  .dropIcon{font-size:20px;color:var(--accent)}
  .previewBox{width:1in;height:1in;border-radius:8px;overflow:hidden;border:1px solid rgba(255,255,255,0.06);background:#05040a;display:flex;align-items:center;justify-content:center}
  .previewBox img{width:100%;height:100%;object-fit:cover;display:block}

  select, button{background:transparent;border:1px solid rgba(255,255,255,0.08);padding:8px 10px;border-radius:10px;color:var(--muted);font-size:13px}
  button.primary{background:linear-gradient(90deg,var(--accent),var(--accent2));color:#111;border:0;box-shadow:0 8px 30px rgba(122,252,255,0.06)}

  .photoWrap{margin-top:12px;border-radius:10px;overflow:hidden;border:1px solid rgba(255,255,255,0.04);display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.22)}
  canvas#photoCanvas{width:100%;height:auto;display:block;max-height:520px}

  #thumbs{display:grid;grid-template-columns:repeat(auto-fill,minmax(84px,1fr));gap:10px;margin-top:12px}
  .thumb{border-radius:10px;padding:6px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00)); border:1px solid rgba(255,255,255,0.03); cursor:pointer; display:flex;align-items:center;justify-content:center;min-height:84px;position:relative}
  .thumb img{width:100%;height:100%;object-fit:cover;border-radius:6px;display:block}

  .bigPreview{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(rgba(1,2,6,0.6), rgba(1,2,6,0.9));z-index:999;visibility:hidden;opacity:0;transition:opacity .15s}
  .bigPreview.open{visibility:visible;opacity:1}
  .bigBox{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:12px;border-radius:12px;display:flex;gap:12px;align-items:flex-start;max-width:96%;max-height:92%;overflow:auto}
  .bigBox canvas{max-width:820px;max-height:80vh;border-radius:8px;display:block}

  .statusLog{margin-top:10px;font-size:13px;color:rgba(255,255,255,0.85);background:rgba(0,0,0,0.18);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03)}
  .muted{font-size:12px;color:rgba(255,255,255,0.6)}

  footer{z-index:2;display:flex;align-items:center;justify-content:center;width:100%;max-width:1100px;margin-top:8px;padding:10px 0}
  .credit{font-family:"Brush Script MT","Lucida Handwriting",cursive;color:#ffeafa;font-size:20px;position:relative;padding:6px 14px;border-radius:20px;overflow:hidden}
  .credit::after{content:'';position:absolute;inset:0;background:linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.22) 45%, rgba(255,255,255,0) 80%);transform:translateX(-120%);animation:lightmove 2.2s linear infinite;mix-blend-mode:overlay}
  @keyframes lightmove{0%{transform:translateX(-120%);}50%{transform:translateX(120%);}100%{transform:translateX(-120%);}}
  @media (max-width:700px){ main{flex-direction:column} .right{width:100%}}
</style>
</head>
<body>
  <div class="neon-bg" aria-hidden="true"></div>

  <header>
    <div class="logo">H</div>
    <div>
      <h1 style="margin:0">Neon HairTry â€” Barbershop Preview (Option B)</h1>
      <div style="font-size:12px;color:rgba(255,255,255,0.7)">Built-in overlays â€” face preserved</div>
    </div>
  </header>

  <main>
    <section class="left">
      <div style="display:flex;gap:12px;align-items:flex-start">
        <div>
          <div class="uploadRow">
            <div id="dropTarget" class="dropTarget" title="Click or drop an image">
              <div class="dropIcon">ðŸ“·</div>
              <input id="fileInput" type="file" accept="image/*" style="position:absolute;inset:0;opacity:0;cursor:pointer" />
            </div>

            <div style="display:flex;flex-direction:column;gap:6px">
              <div style="font-size:11px;color:rgba(255,255,255,0.6)">Tap the square to upload (1Ã—1 inch)</div>
              <div style="display:flex;gap:8px;align-items:center">
                <select id="gender">
                  <option value="male">Male</option>
                  <option value="female">Female</option>
                </select>
                <button id="cameraBtn">ðŸ“¸ Camera</button>
                <button id="analyzeBtn" class="primary">Auto-generate</button>
              </div>
            </div>
          </div>

          <div style="display:flex;gap:8px;margin-top:10px;align-items:center">
            <div class="previewBox" id="previewBox" aria-hidden="true"><div style="color:#666;font-size:11px">preview</div></div>
            <div style="display:flex;flex-direction:column">
              <div id="detColor" style="width:48px;height:20px;border-radius:6px;border:1px solid rgba(255,255,255,0.04)"></div>
              <div class="muted" id="textureTag">texture: â€”</div>
            </div>
          </div>

          <div class="statusLog" id="statusLog">Status: ready</div>
        </div>

        <div style="flex:1">
          <div class="photoWrap">
            <canvas id="photoCanvas" width="640" height="480" aria-label="Photo preview"></canvas>
          </div>
          <div id="thumbs"></div>
        </div>
      </div>
    </section>

    <aside class="right">
      <div style="font-weight:700">How it works</div>
      <ol style="color:rgba(255,255,255,0.7);font-size:13px;margin-top:8px">
        <li>Upload a frontal photo or use the camera (single prompt only).</li>
        <li>Choose gender â€” male & female templates are available.</li>
        <li>System detects hair color & texture and tints overlays to match. Option B: overlays slightly overlap forehead for salon preview.</li>
        <li>Tap a thumbnail to see the enlarged preview. Face pixels remain unchanged below the forehead clamp.</li>
      </ol>
      <div style="margin-top:12px;font-size:13px;color:rgba(255,255,255,0.7)">
        <strong>Privacy:</strong> Images never leave your browser.
      </div>
    </aside>
  </main>

  <div id="big" class="bigPreview" role="dialog" aria-hidden="true">
    <div class="bigBox" role="document">
      <canvas id="bigCanvas" width="900" height="900"></canvas>
      <div style="display:flex;flex-direction:column;gap:8px;min-width:220px">
        <div style="font-weight:700" id="bigInfo">Preview</div>
        <div id="bigMatch" style="color:rgba(255,255,255,0.7);font-size:13px"></div>
        <div style="margin-top:auto;display:flex;gap:8px">
          <button id="closeBig">Close</button>
          <a id="downloadBtn" download="hairstyle.png"><button>Download</button></a>
        </div>
      </div>
    </div>
  </div>

  <footer><div class="credit">Created by Animesh</div></footer>

  <!-- TensorFlow and FaceLandmarks -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.4.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection@1.0.2/dist/face-landmarks-detection.min.js"></script>

<script>
/* Final single-file app (Option B) with:
   - Single upload
   - On-screen + console logs
   - Proper model loading & status
   - Male + Female inline SVG templates (20 each)
   - HSL recolor to match detected hair color
   - Overlay placement that covers hair + small forehead region
   - Soft mask at forehead to keep facial features intact
*/

(() => {
  // DOM
  const fileInput = document.getElementById('fileInput');
  const dropTarget = document.getElementById('dropTarget');
  const previewBox = document.getElementById('previewBox');
  const photoCanvas = document.getElementById('photoCanvas');
  const pctx = photoCanvas.getContext('2d', { willReadFrequently:true });
  const statusLog = document.getElementById('statusLog');
  const detColor = document.getElementById('detColor');
  const textureTag = document.getElementById('textureTag');
  const analyzeBtn = document.getElementById('analyzeBtn');
  const cameraBtn = document.getElementById('cameraBtn');
  const genderSelect = document.getElementById('gender');
  const thumbs = document.getElementById('thumbs');
  const bigModal = document.getElementById('big');
  const bigCanvas = document.getElementById('bigCanvas');
  const bigCtx = bigCanvas.getContext('2d');
  const bigInfo = document.getElementById('bigInfo');
  const bigMatch = document.getElementById('bigMatch');
  const closeBig = document.getElementById('closeBig');
  const downloadBtn = document.getElementById('downloadBtn');

  let lastImage = null;
  let model = null;
  let detectedHairColor = [120,80,60];
  let detectedTexture = 'unknown';

  // STATUS helpers
  function log(msg){
    console.log('[NeonHairTry]', msg);
    statusLog.textContent = 'Status: ' + msg;
  }

  function errorLog(msg){
    console.error('[NeonHairTry]', msg);
    statusLog.textContent = 'Error: ' + msg;
  }

  // Load model and show progress
  async function loadModel(){
    try{
      log('Loading face model...');
      model = await faceLandmarksDetection.load(faceLandmarksDetection.SupportedPackages.mediapipeFacemesh, { maxFaces: 1 });
      log('Face model loaded');
    }catch(e){
      errorLog('Model load failed â€” check console. ' + (e.message || e));
    }
  }
  loadModel();

  // SINGLE file input (prevents double prompt)
  dropTarget.addEventListener('click', ()=> fileInput.click());
  dropTarget.addEventListener('dragover', (e)=>{ e.preventDefault(); dropTarget.style.borderColor='rgba(122,252,255,0.7)'; });
  dropTarget.addEventListener('dragleave', ()=>{ dropTarget.style.borderColor='rgba(255,255,255,0.12)'; });
  dropTarget.addEventListener('drop', async (e)=>{ e.preventDefault(); dropTarget.style.borderColor='rgba(255,255,255,0.12)'; const f = e.dataTransfer.files?.[0]; if(f) await handleFile(f); });

  fileInput.addEventListener('change', async (e)=>{ const f = e.target.files?.[0]; if(!f) return; await handleFile(f); fileInput.value=''; });

  async function handleFile(file){
    try{
      log('Reading image...');
      const img = await fileToImage(file);
      lastImage = img;
      photoCanvas.width = img.naturalWidth || img.width;
      photoCanvas.height = img.naturalHeight || img.height;
      pctx.clearRect(0,0,photoCanvas.width,photoCanvas.height);
      pctx.drawImage(img,0,0);
      previewBox.innerHTML=''; const p = document.createElement('img'); p.src = photoCanvas.toDataURL('image/jpeg',0.9); previewBox.appendChild(p);
      log('Image loaded');
      await analyzeAndGenerate(); // auto-run
    }catch(e){
      errorLog('Failed to read image: ' + (e.message || e));
    }
  }

  function fileToImage(file){
    return new Promise((res, rej)=>{
      const r = new FileReader();
      r.onload = ()=>{ const img = new Image(); img.onload = ()=>res(img); img.onerror = rej; img.src = r.result; };
      r.onerror = rej; r.readAsDataURL(file);
    });
  }

  // Camera single-shot
  cameraBtn.addEventListener('click', async ()=>{
    try{
      log('Opening camera...');
      const stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'user' }, audio:false });
      const v = document.createElement('video'); v.autoplay=true; v.playsInline=true; v.muted=true;
      v.srcObject = stream;
      await v.play();
      // draw one frame then stop
      photoCanvas.width = v.videoWidth || 640;
      photoCanvas.height = v.videoHeight || 480;
      pctx.drawImage(v,0,0,photoCanvas.width,photoCanvas.height);
      stream.getTracks().forEach(t=>t.stop());
      const img = new Image(); img.onload = ()=>{ lastImage = img; previewBox.innerHTML=''; previewBox.appendChild(img); }; img.src = photoCanvas.toDataURL('image/jpeg',0.95);
      log('Camera snapshot captured');
      await analyzeAndGenerate();
    }catch(e){
      errorLog('Camera error: ' + (e.message || e));
    }
  });

  // Color & texture helpers
  function samplePixels(x,y,w,h,step=6){
    try{
      const id = pctx.getImageData(Math.max(0,x),Math.max(0,y),Math.max(1,w),Math.max(1,h));
      const d = id.data; const out=[];
      for(let i=0;i<d.length;i+=4*step) out.push([d[i],d[i+1],d[i+2]]);
      return out;
    }catch(e){ return []; }
  }
  function kmeans2(pixels,iter=6){
    if(!pixels.length) return [120,80,60];
    let c1 = pixels[0].slice(), c2 = pixels[Math.floor(pixels.length/2)].slice();
    for(let it=0; it<iter; it++){
      const s1=[0,0,0,0], s2=[0,0,0,0];
      for(const p of pixels){
        const d1=(p[0]-c1[0])**2+(p[1]-c1[1])**2+(p[2]-c1[2])**2;
        const d2=(p[0]-c2[0])**2+(p[1]-c2[1])**2+(p[2]-c2[2])**2;
        if(d1<d2){ s1[0]+=p[0];s1[1]+=p[1];s1[2]+=p[2];s1[3]++; } else { s2[0]+=p[0];s2[1]+=p[1];s2[2]+=p[2];s2[3]++; }
      }
      if(s1[3]>0) c1=[Math.round(s1[0]/s1[3]),Math.round(s1[1]/s1[3]),Math.round(s1[2]/s1[3])];
      if(s2[3]>0) c2=[Math.round(s2[0]/s2[3]),Math.round(s2[1]/s2[3]),Math.round(s2[2]/s2[3])];
    }
    // choose darker cluster roughly
    const lum = arr => 0.2126*arr[0] + 0.7152*arr[1] + 0.0722*arr[2];
    return lum(c1) < lum(c2) ? c1 : c2;
  }
  function textureIndex(x,y,w,h){
    try{
      const id = pctx.getImageData(Math.max(0,x),Math.max(0,y),Math.max(1,w),Math.max(1,h));
      const d=id.data; const width=w; const height=h; let edge=0, tot=0;
      for(let yy=1; yy<height-1; yy+=3){
        for(let xx=1; xx<width-1; xx+=3){
          const idx = (yy*width+xx)*4;
          const r=d[idx],g=d[idx+1],b=d[idx+2];
          const r2=d[idx+4],g2=d[idx+5],b2=d[idx+6];
          const r3=d[idx+width*4],g3=d[idx+width*4+1],b3=d[idx+width*4+2];
          const mag = Math.abs(r-r2)+Math.abs(g-g2)+Math.abs(b-b2)+Math.abs(r-r3)+Math.abs(g-g3)+Math.abs(b-b3);
          if(mag>40) edge++; tot++;
        }
      }
      return tot? edge/tot : 0;
    }catch(e){ return 0; }
  }

  // RGB <-> HSL
  function rgbToHsl(r,g,b){
    r/=255; g/=255; b/=255;
    const max=Math.max(r,g,b), min=Math.min(r,g,b);
    let h=0,s=0,l=(max+min)/2;
    if(max!==min){
      const d = max-min; s = l>0.5 ? d/(2-max-min) : d/(max+min);
      switch(max){ case r: h=(g-b)/d + (g<b?6:0); break; case g: h=(b-r)/d + 2; break; case b: h=(r-g)/d + 4; break; }
      h/=6;
    }
    return [h,s,l];
  }
  function hslToRgb(h,s,l){
    let r,g,b;
    if(s===0){ r=g=b=l; } else {
      const hue2rgb=(p,q,t)=>{ if(t<0) t+=1; if(t>1) t-=1; if(t<1/6) return p+(q-p)*6*t; if(t<1/2) return q; if(t<2/3) return p + (q-p)*(2/3 - t)*6; return p; };
      const q = l<0.5 ? l*(1+s) : l + s - l*s;
      const p = 2*l - q;
      r = hue2rgb(p,q,h+1/3); g = hue2rgb(p,q,h); b = hue2rgb(p,q,h-1/3);
    }
    return [Math.round(r*255),Math.round(g*255),Math.round(b*255)];
  }

  // Recolor SVG by replacing placeholder token with computed hex (simple)
  function svgDataUriWithColor(svg, rgb){
    const hex = '#' + ((1<<24) + (rgb[0]<<16) + (rgb[1]<<8) + rgb[2]).toString(16).slice(1);
    const colored = svg.replace(/__HAIR_FILL__/g, hex);
    return 'data:image/svg+xml;utf8,' + encodeURIComponent(colored);
  }

  // Inline templates (Option B design: a bit bigger, overlaps forehead)
  // Each template uses token __HAIR_FILL__ for color replacement.
  // For brevity: both lists contain 20 entries each (simplified vector shapes).
  // (These SVGs are designed frontal, barbershop-like)
  const maleTemplates = [
    { id:'m1',name:'Buzz',texture:'straight', svg:`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 420'><path d='M40 150 C60 80 120 40 200 40 C280 40 340 80 360 150 C360 220 320 240 200 240 C80 240 40 220 40 150 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'m2',name:'Crew',texture:'straight', svg:`<svg ...> <path d='M44 150 C68 78 130 46 200 46 C270 46 332 78 356 150 C356 210 320 230 200 230 C80 230 44 210 44 150 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'m3',name:'Fade',texture:'straight', svg:`<svg ...><path d='M36 150 C66 70 140 30 200 30 C260 30 334 70 364 150 C352 190 320 220 200 220 C90 220 60 190 36 150 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'m4',name:'Textured Crop',texture:'wavy', svg:`<svg ...><path d='M44 150 C80 70 140 48 200 52 C260 48 320 70 356 150 C340 176 300 186 200 200 C100 186 60 176 44 150 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'m5',name:'Undercut',texture:'straight', svg:`<svg ...><path d='M40 150 C80 60 150 40 200 40 C250 40 320 60 360 150 C360 210 330 230 200 230 C70 230 40 210 40 150 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'m6',name:'Pompadour',texture:'wavy', svg:`<svg ...><path d='M30 150 C90 40 150 16 200 24 C250 16 310 40 370 150 C340 190 300 210 200 210 C100 210 60 190 30 150 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'m7',name:'Quiff',texture:'wavy', svg:`<svg ...><path d='M36 150 C92 48 160 28 200 36 C240 28 308 48 364 150 C342 186 300 204 200 210 C100 204 58 186 36 150 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'m8',name:'Slick Back',texture:'straight', svg:`<svg ...><path d='M40 150 C80 60 160 30 200 30 C240 30 320 60 360 150 C352 190 310 210 200 210 C90 210 48 190 40 150 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'m9',name:'Side Part',texture:'straight', svg:`<svg ...><path d='M44 150 C84 68 150 44 200 46 C250 44 316 68 356 150 C336 178 300 192 200 204 C100 192 64 178 44 150 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'m10',name:'Mullet',texture:'wavy', svg:`<svg ...><path d='M40 150 C70 78 140 48 200 48 C260 48 330 78 360 150 C360 220 320 300 200 300 C80 300 40 220 40 150 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'m11',name:'Spiky',texture:'straight', svg:`<svg ...><path d='M40 150 C72 74 128 46 200 46 C272 46 328 74 360 150 C344 176 300 194 200 204 C100 194 56 176 40 150 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'m12',name:'Curly Top',texture:'curly', svg:`<svg ...><path d='M44 150 C78 86 126 60 200 60 C274 60 322 86 356 150 C356 190 320 200 200 210 C80 200 44 190 44 150 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'m13',name:'High Fade',texture:'straight', svg:`<svg ...><path d='M36 150 C66 70 140 30 200 30 C260 30 334 70 364 150 C352 190 320 220 200 220 C90 220 60 190 36 150 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'m14',name:'Undercut Waves',texture:'wavy', svg:`<svg ...><path d='M40 150 C90 64 150 40 200 44 C250 40 320 64 360 150 C340 186 300 200 200 208 C100 200 60 186 40 150 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'m15',name:'Curly Undercut',texture:'curly', svg:`<svg ...><path d='M50 150 C90 88 150 66 200 70 C250 66 310 88 350 150 C338 186 300 200 200 212 C100 200 62 186 50 150 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'m16',name:'Top Knot',texture:'wavy', svg:`<svg ...><path d='M36 150 C80 68 150 38 200 38 C250 38 320 68 364 150 C344 186 300 204 200 210 C100 204 56 186 36 150 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'m17',name:'Long Sweep',texture:'wavy', svg:`<svg ...><path d='M40 150 C68 76 126 40 200 36 C274 40 332 76 360 150 C360 220 320 280 200 300 C80 280 40 220 40 150 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'m18',name:'Man Bun',texture:'straight', svg:`<svg ...><path d='M40 150 C90 60 150 36 200 36 C250 36 310 60 360 150 C360 220 320 300 200 300 C80 300 40 220 40 150 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'m19',name:'Curtain',texture:'wavy', svg:`<svg ...><path d='M40 150 C72 84 130 50 200 50 C270 50 328 84 360 150 C344 176 300 188 200 200 C100 188 56 176 40 150 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'m20',name:'Textured Short',texture:'wavy', svg:`<svg ...><path d='M44 150 C80 72 140 44 200 48 C260 44 320 72 356 150 C340 176 300 186 200 198 C100 186 60 176 44 150 Z' fill='__HAIR_FILL__'/></svg>`}
  ];

  const femaleTemplates = [
    { id:'f1',name:'Short Bob',texture:'straight', svg:`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 420'><path d='M36 140 C74 80 132 56 200 56 C268 56 326 80 364 140 C364 220 320 260 200 260 C80 260 36 220 36 140 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'f2',name:'Long Straight',texture:'straight', svg:`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 420'><path d='M40 140 C80 60 140 46 200 46 C260 46 320 60 360 140 C360 320 300 380 200 380 C100 380 40 320 40 140 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'f3',name:'Layered Medium',texture:'wavy', svg:`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 420'><path d='M38 140 C82 70 150 56 200 60 C250 56 318 70 362 140 C338 176 300 180 200 196 C100 180 62 176 38 140 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'f4',name:'Curtain Bangs',texture:'wavy', svg:`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 420'><path d='M36 140 C78 74 134 54 200 54 C266 54 322 74 364 140 C344 176 300 188 200 200 C100 188 56 176 36 140 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'f5',name:'Pixie',texture:'straight', svg:`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 420'><path d='M52 140 C92 78 150 52 200 52 C250 52 308 78 348 140 C336 176 300 184 200 200 C100 184 64 176 52 140 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'f6',name:'Wavy Shoulder',texture:'wavy', svg:`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 420'><path d='M40 140 C86 64 146 46 200 50 C254 46 314 64 360 140 C360 320 300 380 200 380 C100 380 40 320 40 140 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'f7',name:'Top Knot',texture:'straight', svg:`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 420'><path d='M36 140 C80 64 150 46 200 46 C250 46 320 64 364 140 C344 176 300 198 200 210 C100 198 56 176 36 140 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'f8',name:'Long Curls',texture:'curly', svg:`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 420'><path d='M44 140 C88 78 150 62 200 64 C250 62 312 78 356 140 C356 320 300 380 200 380 C100 380 44 320 44 140 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'f9',name:'Braided Side',texture:'curly', svg:`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 420'><path d='M44 140 C80 86 144 64 200 64 C256 64 320 86 356 140 C344 176 300 198 200 208 C100 198 56 176 44 140 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'f10',name:'Soft Layers',texture:'wavy', svg:`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 420'><path d='M36 140 C78 72 136 50 200 52 C264 50 322 72 364 140 C344 176 300 190 200 200 C100 190 56 176 36 140 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'f11',name:'Chin-Length',texture:'straight', svg:`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 420'><path d='M40 140 C78 74 140 56 200 56 C262 56 322 74 360 140 C360 220 320 260 200 260 C80 260 40 220 40 140 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'f12',name:'Deep Side Part',texture:'straight', svg:`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 420'><path d='M36 140 C80 72 150 50 200 50 C250 50 320 72 364 140 C344 176 300 186 200 198 C100 186 56 176 36 140 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'f13',name:'Half-Up',texture:'wavy', svg:`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 420'><path d='M36 140 C80 68 140 46 200 48 C260 46 320 68 364 140 C344 176 300 186 200 198 C100 186 56 176 36 140 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'f14',name:'Loose Pony',texture:'straight', svg:`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 420'><path d='M40 140 C80 60 150 46 200 46 C250 46 320 60 360 140 C360 320 300 380 200 380 C100 380 40 320 40 140 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'f15',name:'Sleek Bob',texture:'straight', svg:`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 420'><path d='M36 140 C74 80 132 56 200 56 C268 56 326 80 364 140 C364 220 320 260 200 260 C80 260 36 220 36 140 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'f16',name:'Shag',texture:'wavy', svg:`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 420'><path d='M36 140 C82 70 150 56 200 60 C250 56 318 70 362 140 C338 176 300 180 200 196 C100 180 62 176 36 140 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'f17',name:'Beach Waves',texture:'wavy', svg:`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 420'><path d='M40 140 C86 64 146 46 200 50 C254 46 314 64 360 140 C360 320 300 380 200 380 C100 380 40 320 40 140 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'f18',name:'Voluminous Curls',texture:'curly', svg:`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 420'><path d='M44 140 C88 78 150 62 200 64 C250 62 312 78 356 140 C356 320 300 380 200 380 C100 380 44 320 44 140 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'f19',name:'Boho Layers',texture:'wavy', svg:`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 420'><path d='M36 140 C78 72 136 50 200 52 C264 50 322 72 364 140 C344 176 300 190 200 200 C100 190 56 176 36 140 Z' fill='__HAIR_FILL__'/></svg>`},
    { id:'f20',name:'Soft Curtain',texture:'wavy', svg:`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 420'><path d='M40 140 C72 84 130 50 200 50 C270 50 328 84 360 140 C344 176 300 188 200 200 C100 188 56 176 40 140 Z' fill='__HAIR_FILL__'/></svg>`}
  ];

  // Build thumbnails (tint SVG with detected color)
  async function buildThumbnails(pred){
    thumbs.innerHTML = '';
    const gender = genderSelect.value === 'female' ? 'female' : 'male';
    const templates = gender === 'female' ? femaleTemplates : maleTemplates;
    log(`Building ${templates.length} thumbnails (${gender})...`);
    for(const t of templates){
      const div = document.createElement('div'); div.className='thumb';
      const img = document.createElement('img'); img.alt = t.name;
      div.appendChild(img);
      thumbs.appendChild(div);
      const dataUri = svgDataUriWithColor(t.svg, detectedHairColor);
      img.src = dataUri;
      // show texture match badge
      if(t.texture === detectedTexture){
        const badge = document.createElement('div'); badge.textContent='â˜…'; badge.style.position='absolute'; badge.style.top='6px'; badge.style.right='8px'; badge.style.color='#ffd166';
        div.appendChild(badge);
      }
      div.onclick = ()=>applyBig(dataUri, t.name, pred);
    }
    log('Thumbnails ready');
  }

  // Place overlay on big canvas (Option B: overlap forehead slightly with soft alpha mask)
  async function applyBig(svgDataUri, name, pred){
    if(!lastImage) return;
    log('Rendering preview: ' + name);
    const maxW = 900, maxH = 900;
    const scale = Math.min(maxW/lastImage.width, maxH/lastImage.height, 1);
    const pw = Math.round(lastImage.width*scale), ph = Math.round(lastImage.height*scale);
    bigCanvas.width = pw; bigCanvas.height = ph;
    bigCtx.clearRect(0,0,pw,ph);
    // draw face unchanged first
    bigCtx.drawImage(lastImage, 0,0, pw, ph);

    // attempt to compute face width / forehead position using landmarks if present
    const lms = (pred && (pred.scaledMesh || pred.mesh)) || [];
    let left=null, right=null, minY=1e9;
    if(lms && lms.length){
      left = lms[234] || lms[33];
      right = lms[454] || lms[263];
      lms.forEach(pt=>{ if(pt && pt[1] < minY) minY = pt[1]; });
    }
    if(!left || !right){
      left = [lastImage.width*0.28, lastImage.height*0.45];
      right = [lastImage.width*0.72, lastImage.height*0.45];
      minY = lastImage.height*0.18;
    }
    const faceW = Math.hypot((right[0]-left[0]), (right[1]-left[1])) * scale;
    const targetW = faceW * 1.35; // Option B: slightly wider
    const overlayImg = new Image(); overlayImg.crossOrigin='anonymous'; overlayImg.src = svgDataUri;
    await new Promise((r,rej)=>{ overlayImg.onload=r; overlayImg.onerror=rej; });
    const imgScale = targetW / overlayImg.width;
    const dw = overlayImg.width * imgScale;
    const dh = overlayImg.height * imgScale;
    const centerX = ((left[0]+right[0])/2) * scale;
    const dx = centerX - dw/2;
    const dy = (minY * scale) - dh*0.28; // move up so it overlaps forehead a bit

    // Prepare offscreen mask-limited draw: we want soft fade near forehead boundary to keep features visible
    const off = document.createElement('canvas'); off.width = pw; off.height = ph;
    const octx = off.getContext('2d');
    octx.clearRect(0,0,pw,ph);
    octx.drawImage(overlayImg, dx, dy, dw, dh);

    // Create vertical mask where above forehead keeps full alpha and below forehead fades
    const mask = octx.createLinearGradient(0, dy + dh*0.18, 0, dy + dh*0.42);
    mask.addColorStop(0, 'rgba(0,0,0,1)');
    mask.addColorStop(0.6, 'rgba(0,0,0,0.45)');
    mask.addColorStop(1, 'rgba(0,0,0,0)');
    // Draw mask into a 1px wide mask canvas and sample it
    const maskCanvas = document.createElement('canvas'); maskCanvas.width = 1; maskCanvas.height = ph;
    const mctx = maskCanvas.getContext('2d');
    mctx.fillStyle = mask; mctx.fillRect(0,0,1,ph);
    const maskData = mctx.getImageData(0,0,1,ph).data;

    try{
      const id = octx.getImageData(0,0,pw,ph);
      const d = id.data;
      for(let y=0;y<ph;y++){
        const malpha = maskData[y*4+3]/255;
        if(malpha === 1) continue; // no change
        for(let x=0;x<pw;x++){
          const idx = (y*pw + x)*4;
          if(d[idx+3] === 0) continue;
          // scale alpha
          d[idx+3] = Math.round(d[idx+3] * malpha);
        }
      }
      octx.putImageData(id,0,0);
      // Draw masked overlay on top of original
      bigCtx.drawImage(off,0,0);
    }catch(e){
      // fallback: draw normally
      bigCtx.drawImage(overlayImg, dx, dy, dw, dh);
    }

    bigInfo.textContent = name;
    bigMatch.textContent = `Detected color: rgb(${detectedHairColor.join(',')}) â€¢ texture: ${detectedTexture}`;
    bigModal.classList.add('open'); bigModal.setAttribute('aria-hidden','false');
    downloadBtn.href = bigCanvas.toDataURL('image/png');
    log('Preview rendered');
  }

  // Analyze: detect face, determine hair region (above forehead), color & texture, then build thumbnails
  async function analyzeAndGenerate(){
    if(!lastImage){
      errorLog('Please upload or capture a photo first');
      return;
    }
    if(!model){
      log('Model still loading â€” waiting...');
      // try waiting a bit
      const start = Date.now();
      while(!model && Date.now() - start < 15000) await new Promise(r => setTimeout(r, 300));
      if(!model){
        errorLog('Model not loaded. Reload page or check console.');
        return;
      }
    }
    log('Detecting face landmarks...');
    let preds = [];
    try{
      preds = await model.estimateFaces({ input: photoCanvas, flipHorizontal:false });
    }catch(e){
      errorLog('Face detection error: ' + (e.message || e));
      return;
    }
    if(!preds || preds.length === 0){
      errorLog('No face detected. Use a clear frontal photo.');
      return;
    }
    const p = preds[0];
    // compute bounding box of landmarks
    const lms = p.scaledMesh || p.mesh || [];
    let minX=photoCanvas.width, minY=photoCanvas.height, maxX=0, maxY=0;
    lms.forEach(pt => { if(!pt) return; const x=pt[0], y=pt[1]; if(x<minX)minX=x; if(y<minY)minY=y; if(x>maxX)maxX=x; if(y>maxY)maxY=y; });
    const w = Math.max(20, Math.round(maxX - minX)), h = Math.max(20, Math.round(maxY - minY));
    // hair region: extend well above the forehead (since Option B we want overlap)
    let hx = Math.max(0, Math.round(minX - w*0.12));
    let hy = Math.max(0, Math.round(minY - h*1.05));
    let hw = Math.min(photoCanvas.width - hx, Math.round(w * 1.3));
    let hh = Math.min(photoCanvas.height - hy, Math.round(h * 1.9));
    if(hw <= 0 || hh <= 0){
      hx = Math.max(0, Math.round(minX)); hy = Math.max(0, Math.round(minY - h*0.6));
      hw = Math.min(photoCanvas.width - hx, Math.round(w*1.1));
      hh = Math.min(photoCanvas.height - hy, Math.round(h*1.2));
    }
    log(`Sampling hair region at x=${hx}, y=${hy}, w=${hw}, h=${hh}`);
    const pixels = samplePixels(hx, hy, hw, hh, 6);
    const dom = kmeans2(pixels, 7);
    detectedHairColor = dom;
    detColor.style.background = `rgb(${dom[0]},${dom[1]},${dom[2]})`;
    const tidx = textureIndex(hx, hy, hw, hh);
    detectedTexture = tidx < 0.09 ? 'straight' : tidx < 0.18 ? 'wavy' : 'curly';
    textureTag.textContent = 'texture: ' + detectedTexture;
    log('Detected hair color & texture');
    await buildThumbnails(p);
  }

  // Small helpers
  function rgbToHex(rgb){
    const [r,g,b]=rgb; return "#" + ((1<<24) + (r<<16) + (g<<8) + b).toString(16).slice(1);
  }
  function svgDataUriWithColor(svg, rgb){ const hex = rgbToHex(rgb); return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg.replace(/__HAIR_FILL__/g, hex)); }

  // Wire UI
  analyzeBtn.addEventListener('click', analyzeAndGenerate);
  closeBig.addEventListener('click', ()=>{ bigModal.classList.remove('open'); bigModal.setAttribute('aria-hidden','true'); });
  bigModal.addEventListener('click', (e)=>{ if(e.target === bigModal) { bigModal.classList.remove('open'); bigModal.setAttribute('aria-hidden','true'); } });
  window.addEventListener('keydown', (e)=>{ if(e.key === 'Escape'){ bigModal.classList.remove('open'); bigModal.setAttribute('aria-hidden','true'); } });

  // file->image conversion (used by camera)
  function fileToImage(file){
    return new Promise((res, rej)=>{
      const r = new FileReader();
      r.onload = ()=>{ const img = new Image(); img.onload = ()=>res(img); img.onerror = rej; img.src = r.result; };
      r.onerror = rej; r.readAsDataURL(file);
    });
  }

  // Helper used earlier (ensure single definition, fallback)
  async function handleFile(file){ // redefined to ensure scope
    try{ log('Reading image...'); const img = await fileToImage(file); lastImage = img; photoCanvas.width = img.naturalWidth || img.width; photoCanvas.height = img.naturalHeight || img.height; pctx.clearRect(0,0,photoCanvas.width,photoCanvas.height); pctx.drawImage(img,0,0); previewBox.innerHTML=''; const p = document.createElement('img'); p.src = photoCanvas.toDataURL('image/jpeg',0.9); previewBox.appendChild(p); log('Image loaded'); await analyzeAndGenerate(); }catch(e){ errorLog('Failed to read image: ' + (e.message || e)); }
  }

  // Expose file handler for earlier binding (replace existing one)
  fileInput.onchange = async (e)=>{ const f = e.target.files?.[0]; if(!f) return; await handleFile(f); fileInput.value=''; };

  // Prewarm: small message
  log('Ready â€” click the square to upload a photo. See console for more logs.');

  // Expose to console for debugging
  window.NeonHairTry = { log, modelRef: () => model, lastImage: () => lastImage, analyzeAndGenerate };

})(); // end IIFE
</script>
</body>
</html>
